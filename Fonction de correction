##################  F0NCTION DE CORRECTION DU MOUVEMENT DU KITE EN 2D  #######################





# READ ME

'''Objectif: Automatiser la manoeuvre.'''

'''Méthode : Créer une fonction Correction :
    En entrée : position, forces subies, trajectoire souhaitée (en 8)
    En sortie : Vecteur correcteur permettant de rejoindre le mouvement souhaité'''





# IMPORTATION DES MODULES

import math
import matplotlib.pyplot as plt
import numpy as np
'''On se contentera pour l'intant d'une modélisation en 2D'''





# CREATION D'UNE CLASSE VECTEUR 2D

'''Permet d'améliorer la gestion du code, et de grandement faciliter sa lisibilité et sa compréhension'''

class Vecteur :

    def __init__ (self,x,y) :
        self.x = x
        self.y = y

    def __repr__ (self) :
        return '(' + str(self.x) + ',' + str(self.y) + ')'

    def Dessine (self,x,y,couleur) :
        ''' Représente le vecteur self à l'origine (x,y)'''
        if type(self) == Vecteur :
            X = [x , x + self.x]
            Y = [y , y + self.y]
            plt.plot(X,Y,couleur)

    def Addition (self,v) :
        if type(self) == Vecteur and type(v) == Vecteur :
            x = self.x + v.x
            y = self.y + v.y
            return Vecteur(x,y)
        
    def Mult_Scalaire (self,a) :
        if type(self) == Vecteur :
            x = a*self.x
            y = a*self.y
            return Vecteur (x,y)
        
    def Soustraction (self,v) :
        if type(self) == Vecteur and type(v) == Vecteur :
            temp = v.Mult_Scalaire(-1)
            return self.Addition(temp)

    def Produit_Scalaire (self,v) :
        if type(self) == Vecteur and type(v) == Vecteur :        
            return self.x*v.x + self.y*v.y

    def Produit_Vectoriel (self,v) :
        if type(self) == Vecteur and type(v) == Vecteur :
            return 





# DONNEES

'''Courbe théorique (équation paramétrique) :'''

def x(t):
    return np.sin(t)

def y(t):
    return 1/3*np.sin(2*t)


'''T = np.arange(0,4*np.pi+0.01,0.01)
X = x(T)
Y = y(T)
plt.axis('equal')
plt.plot(X,Y)
plt.show'''





# FONCTIONS 

def Calcul_vecteur_théorique (x,y,t,dt) :
    '''retourne vecteur_théorique = Vecteur(f(t)f(t+dt))'''
    xth = x(t+dt) - x(t)
    yth = y(t+dt) - y(t)
    vecteur_théorique = Vecteur(xth,yth)
    return vecteur_théorique


def Calcul_vecteur_non_corrigé(vitesse,Forces):
    '''Equations physiques'''
    vecteur_non_corrigé = Vecteur(0.1,0.1)
    return vecteur_non_corrigé

            
def Calcul_vecteur_correction (vecteur_non_corrigé, vecteur_théorique) :
    return vecteur_théorique.Soustraction(vecteur_non_corrigé)


def Modélisation (x, y, vitesse, Forces, a, b, n) :
    dt = (b-a)/n
    T = np.arange(a,b,dt)
    for t in T :
        vecteur_théorique = Calcul_vecteur_théorique (x, y, t, dt)
        vecteur_non_corrigé = Calcul_vecteur_non_corrigé(vitesse, Forces)
        vecteur_correction = Calcul_vecteur_correction (vecteur_non_corrigé, vecteur_théorique)
        vecteur_théorique.Dessine(x(t), y(t),'k')
        vecteur_non_corrigé.Dessine(x(t), y(t),'orange')
        vecteur_correction.Dessine(x(t), y(t),'g')
        
        



# MODELISATION :

vitesse = 0.1
Forces = 0.1
a = 0
b = 4*np.pi
n = 300


Modélisation (x, y, vitesse, Forces, a, b, n)
plt.show()


        


    

